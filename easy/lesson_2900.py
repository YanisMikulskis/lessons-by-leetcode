class Solution:
    '''
    🟢 Уровень: Лёгкий (Easy)
    📘 Перевод задания:
    У тебя есть:

    массив строк words длины n,
    массив чисел groups длины n, содержащий только 0 и 1.
    Нужно выбрать наибольшую по длине подпоследовательность из words, такую,
    чтобы у каждой пары подряд идущих элементов этой подпоследовательности значения в groups отличались.

    То есть нельзя, чтобы в выбранной подпоследовательности подряд шли элементы,
    у которых одинаковые значения в groups (два нуля подряд или две единицы подряд — нельзя).

    Возврати такую подпоследовательность из words. Если вариантов несколько — можно вернуть любой.

    🔄 Что такое подпоследовательность (subsequence)?
    Это элементы массива в том же порядке, но не обязательно подряд.

    Пример:

    words = ["a", "b", "c"]
    подпоследовательности: ["a", "b"], ["a", "c"], ["b", "c"], ["a", "b", "c"]
    📊 Примеры:
    ✅ Пример 1:

    words = ["e", "a", "b"]
    groups = [0, 0, 1]
    Возможные допустимые подпоследовательности:
    ["e", "b"] — группы: 0 → 1
    ["a", "b"] — группы: 0 → 1
    Нельзя ["e", "a"] — потому что groups[0] == groups[1] == 0
    Ответ: ["e", "b"] или ["a", "b"]


    Пример 2:

    words = ["a", "b", "c", "d"]
    groups = [1, 0, 1, 1]
    Начнем с "a" (group = 1)
    Следующий допустимый — "b" (0)
    Следующий — "c" (1)
    ["a", "b", "c"] — валидно
    Либо можно было ["a", "b", "d"] — тоже длина 3
    Ответ: ["a", "b", "c"] или ["a", "b", "d"]
    '''
    def getLongestSubsequence(self, words: list[str], groups: list[int]) -> list[str]:
        pos, res = groups[0], [words[0]]
        for i in list(zip(words, groups))[1:]:
            if i[1] != pos:
                res, pos = res + [i[0]], i[1]
        return res


sol = Solution()

sol.getLongestSubsequence(words = ["e", "a", "b"], groups = [0, 0, 1])
sol.getLongestSubsequence(words = ["a", "b", "c", "d"], groups=[1,0,1,1])
sol.getLongestSubsequence(words = ["one", "two", "three", "four", "five"], groups = [1, 1, 0, 1, 0])